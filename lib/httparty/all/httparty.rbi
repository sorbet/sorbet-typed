# typed: true

# this is all auto-generated by `srb rbi gems`
# manual additions are at the bottom
module HTTParty
  def self.copy(*args, &block); end
  def self.delete(*args, &block); end
  def self.get(*args, &block); end
  def self.head(*args, &block); end
  def self.included(base); end
  def self.move(*args, &block); end
  def self.normalize_base_uri(url); end
  def self.options(*args, &block); end
  def self.patch(*args, &block); end
  def self.post(*args, &block); end
  def self.put(*args, &block); end
end
module HTTParty::ModuleInheritableAttributes
  def self.hash_deep_dup(hash); end
  def self.included(base); end
end
module HTTParty::ModuleInheritableAttributes::ClassMethods
  def inherited(subclass); end
  def mattr_inheritable(*args); end
end
class HTTParty::CookieHash < Hash
  def add_cookies(value); end
  def to_cookie_string; end
end
module Net
end
module Net::HTTPHeader
  def digest_auth(username, password, response); end
end
class Net::HTTPHeader::DigestAuthenticator
  def a1; end
  def a2; end
  def algorithm_present?; end
  def authorization_header; end
  def cookie_header; end
  def initialize(username, password, method, path, response_header); end
  def md5(str); end
  def opaque_present?; end
  def parse(response_header); end
  def parse_cookies(response_header); end
  def qop_present?; end
  def random; end
  def request_digest; end
  def use_md5_sess?; end
end
class HTTParty::ConnectionAdapter
  def add_max_retries?(max_retries); end
  def add_timeout?(timeout); end
  def attach_ssl_certificates(http, options); end
  def clean_host(host); end
  def connection; end
  def from_ruby_version(ruby_version, option: nil, warn: nil); end
  def initialize(uri, options = nil); end
  def options; end
  def self.call(uri, options); end
  def self.default_cert_store; end
  def ssl_implied?(uri); end
  def strip_ipv6_brackets(host); end
  def uri; end
  def verify_ssl_certificate?; end
end
module HTTParty::Logger
  def self.add_formatter(name, formatter); end
  def self.build(logger, level, formatter); end
  def self.formatters; end
end
class HTTParty::Logger::ApacheFormatter
  def content_length; end
  def current_time; end
  def format(request, response); end
  def http_method; end
  def initialize(logger, level); end
  def level; end
  def level=(arg0); end
  def logger; end
  def logger=(arg0); end
  def message; end
  def path; end
  def request; end
  def response; end
end
class HTTParty::Logger::CurlFormatter
  def current_time; end
  def format(request, response); end
  def initialize(logger, level); end
  def level; end
  def level=(arg0); end
  def log(direction, line = nil); end
  def log_hash(hash); end
  def log_headers; end
  def log_query; end
  def log_request; end
  def log_response; end
  def log_response_headers; end
  def log_url; end
  def logger; end
  def logger=(arg0); end
  def messages; end
  def messages=(arg0); end
  def request; end
  def response; end
end
class HTTParty::Logger::LogstashFormatter
  def content_length; end
  def current_time; end
  def format(request, response); end
  def http_method; end
  def initialize(logger, level); end
  def level; end
  def level=(arg0); end
  def logger; end
  def logger=(arg0); end
  def logstash_message; end
  def message; end
  def path; end
  def request; end
  def response; end
end
class HTTParty::Request
  def assume_utf16_is_big_endian; end
  def base_uri; end
  def capture_cookies(response); end
  def check_duplicate_location_header; end
  def connection_adapter; end
  def credentials; end
  def digest_auth?; end
  def encode_text(text, content_type); end
  def format; end
  def format_from_mimetype(mimetype); end
  def handle_host_redirection; end
  def handle_response(body, &block); end
  def handle_unauthorized(&block); end
  def http; end
  def http_method; end
  def http_method=(arg0); end
  def initialize(http_method, path, o = nil); end
  def last_response; end
  def last_response=(arg0); end
  def last_uri; end
  def last_uri=(arg0); end
  def normalize_query(query); end
  def options; end
  def options=(arg0); end
  def parse_response(body); end
  def parser; end
  def password; end
  def path; end
  def path=(uri); end
  def perform(&block); end
  def post?; end
  def query_string(uri); end
  def query_string_normalizer; end
  def raw_body; end
  def redirect; end
  def redirect=(arg0); end
  def request_uri(uri); end
  def response_has_digest_auth_challenge?; end
  def response_redirects?; end
  def response_unauthorized?; end
  def send_authorization_header?; end
  def set_basic_auth_from_uri; end
  def setup_digest_auth; end
  def setup_raw_request; end
  def uri; end
  def username; end
  def validate; end
end
class HTTParty::Request::MultipartBoundary
  def self.generate; end
end
class HTTParty::Request::Body
  def boundary; end
  def call; end
  def content_type(object); end
  def file?(object); end
  def file_name(object); end
  def force_multipart; end
  def generate_multipart; end
  def has_file?(value); end
  def initialize(params, query_string_normalizer: nil, force_multipart: nil); end
  def multipart?; end
  def normalize_query(query); end
  def params; end
  def query_string_normalizer; end
end
class HTTParty::ResponseFragment < SimpleDelegator
  def code; end
  def connection; end
  def http_response; end
  def initialize(fragment, http_response, connection); end
end
class HTTParty::TextEncoder
  def assume_utf16_is_big_endian; end
  def call; end
  def can_encode?; end
  def charset; end
  def content_type; end
  def encode_utf_16; end
  def encode_with_ruby_encoding; end
  def encoded_text; end
  def initialize(text, assume_utf16_is_big_endian: nil, content_type: nil); end
  def text; end
end
class HTTParty::HeadersProcessor
  def call; end
  def headers; end
  def initialize(headers, options); end
  def options; end
  def process_dynamic_headers; end
end
module HTTParty::HashConversions
  def self.normalize_keys(key, value); end
  def self.normalize_param(key, value); end
  def self.to_params(hash); end
end
module HTTParty::Utils
  def self.stringify_keys(hash); end
end
class HTTParty::Error < StandardError
end
class HTTParty::UnsupportedFormat < HTTParty::Error
end
class HTTParty::UnsupportedURIScheme < HTTParty::Error
end
class HTTParty::ResponseError < HTTParty::Error
  def initialize(response); end
  def response; end
end
class HTTParty::RedirectionTooDeep < HTTParty::ResponseError
end
class HTTParty::DuplicateLocationHeader < HTTParty::ResponseError
end
class HTTParty::Parser
  def body; end
  def csv; end
  def format; end
  def html; end
  def initialize(body, format); end
  def json; end
  def parse; end
  def parse_supported_format; end
  def plain; end
  def self.call(body, format); end
  def self.format_from_mimetype(mimetype); end
  def self.formats; end
  def self.supported_formats; end
  def self.supports_format?(format); end
  def supports_format?; end
  def xml; end
end
class HTTParty::Response
  def _dump(_level); end
  def accepted?; end
  def already_reported?; end
  def bad_gateway?; end
  def bad_request?; end
  def body; end
  def client_error?; end
  def code; end
  def conflict?; end
  def continue?; end
  def created?; end
  def display(port = nil); end
  def early_hints?; end
  def expectation_failed?; end
  def failed_dependency?; end
  def forbidden?; end
  def found?; end
  def gateway_time_out?; end
  def gateway_timeout?; end
  def gone?; end
  def headers; end
  def http_version; end
  def im_used?; end
  def information?; end
  def initialize(request, response, parsed_block, options = nil); end
  def inspect; end
  def insufficient_storage?; end
  def internal_server_error?; end
  def length_required?; end
  def locked?; end
  def loop_detected?; end
  def method_missing(name, *args, &block); end
  def method_not_allowed?; end
  def misdirected_request?; end
  def moved_permanently?; end
  def multi_status?; end
  def multiple_choice?; end
  def multiple_choices?; end
  def network_authentication_required?; end
  def nil?; end
  def no_content?; end
  def non_authoritative_information?; end
  def not_acceptable?; end
  def not_extended?; end
  def not_found?; end
  def not_implemented?; end
  def not_modified?; end
  def ok?; end
  def parsed_response; end
  def partial_content?; end
  def payload_too_large?; end
  def payment_required?; end
  def permanent_redirect?; end
  def precondition_failed?; end
  def precondition_required?; end
  def pretty_print(pp); end
  def processing?; end
  def proxy_authentication_required?; end
  def range_not_satisfiable?; end
  def redirection?; end
  def request; end
  def request_entity_too_large?; end
  def request_header_fields_too_large?; end
  def request_time_out?; end
  def request_timeout?; end
  def request_uri_too_long?; end
  def requested_range_not_satisfiable?; end
  def reset_content?; end
  def respond_to_missing?(name, *args); end
  def response; end
  def see_other?; end
  def self._load(data); end
  def self.underscore(string); end
  def server_error?; end
  def service_unavailable?; end
  def success?; end
  def switch_protocol?; end
  def tap; end
  def temporary_redirect?; end
  def throw_exception; end
  def to_s; end
  def too_many_requests?; end
  def unauthorized?; end
  def unavailable_for_legal_reasons?; end
  def unprocessable_entity?; end
  def unsupported_media_type?; end
  def upgrade_required?; end
  def uri_too_long?; end
  def use_proxy?; end
  def variant_also_negotiates?; end
  def version_not_supported?; end
end
class HTTParty::Response::Headers < SimpleDelegator
  def ==(other); end
  def initialize(header_values = nil); end
  include Net::HTTPHeader
end
module HTTParty::ClassMethods
  def base_uri(uri = nil); end
  def basic_auth(u, p); end
  def ciphers(cipher_names); end
  def connection_adapter(custom_adapter = nil, options = nil); end
  def cookies(h = nil); end
  def copy(path, options = nil, &block); end
  def debug_output(stream = nil); end
  def default_options; end
  def default_params(h = nil); end
  def default_timeout(value); end
  def delete(path, options = nil, &block); end
  def digest_auth(u, p); end
  def disable_rails_query_string_format; end
  def ensure_method_maintained_across_redirects(options); end
  def follow_redirects(value = nil); end
  def format(f = nil); end
  def get(path, options = nil, &block); end
  def head(path, options = nil, &block); end
  def headers(h = nil); end
  def http_proxy(addr = nil, port = nil, user = nil, pass = nil); end
  def lock(path, options = nil, &block); end
  def logger(logger, level = nil, format = nil); end
  def maintain_method_across_redirects(value = nil); end
  def mkcol(path, options = nil, &block); end
  def move(path, options = nil, &block); end
  def no_follow(value = nil); end
  def open_timeout(value); end
  def options(path, options = nil, &block); end
  def parser(custom_parser = nil); end
  def patch(path, options = nil, &block); end
  def pem(pem_contents, password = nil); end
  def perform_request(http_method, path, options, &block); end
  def pkcs12(p12_contents, password); end
  def post(path, options = nil, &block); end
  def process_cookies(options); end
  def put(path, options = nil, &block); end
  def query_string_normalizer(normalizer); end
  def raise_on(codes = nil); end
  def read_timeout(value); end
  def resend_on_redirect(value = nil); end
  def ssl_ca_file(path); end
  def ssl_ca_path(path); end
  def ssl_version(version); end
  def unlock(path, options = nil, &block); end
  def uri_adapter(uri_adapter); end
  def validate_format; end
  def validate_timeout_argument(timeout_type, value); end
  def write_timeout(value); end
end
class HTTParty::Basement
  def self.default_cookies; end
  def self.default_cookies=(arg0); end
  def self.default_options; end
  def self.default_options=(arg0); end
  extend HTTParty::ClassMethods
  extend HTTParty::ModuleInheritableAttributes::ClassMethods
  include HTTParty
  include HTTParty::ModuleInheritableAttributes
end

# this is added manually. it enables you to do self.class.post(URL) in a Client class that includes HTTParty.
module HTTParty
  extend T::Helpers

  mixes_in_class_methods(HTTParty::ClassMethods)
end
